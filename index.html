<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avengers Triangle Quest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-start: #0f0c29;
            --bg-mid: #302b63;
            --bg-end: #24243e;
            --glass-bg: rgba(25, 25, 45, 0.4);
            --glass-border: rgba(0, 229, 255, 0.2);
            --neon-cyan: #00e5ff;
            --neon-pink: #ff00c1;
            --text-light: #e0e0ff;
            --text-dark: #333;
            --success: #00ff88;
            --danger: #ff3366;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(45deg, var(--bg-start), var(--bg-mid), var(--bg-end));
            color: var(--text-light);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
        }

        #stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: -1;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: stars linear infinite;
        }

        @keyframes stars {
            from { transform: translateY(0px); }
            to { transform: translateY(-100vh); }
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5), inset 0 0 1px 1px var(--glass-border);
            position: relative;
            overflow: hidden;
        }

        .glass-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            background-image: url('data:image/svg+xml;utf8,<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(0, 229, 255, 0.1)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)" /></svg>');
            opacity: 0.5;
        }

        /* --- Header --- */
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 1.5rem;
            flex-shrink: 0;
        }

        .game-title {
            font-family: 'Audiowide', sans-serif;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            color: var(--text-light);
            text-shadow: 0 0 5px var(--neon-cyan), 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-pink);
            letter-spacing: 2px;
        }

        .info-hud {
            display: flex;
            gap: 1.5rem;
        }
        
        .info-box {
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text-light);
            font-family: 'Audiowide', sans-serif;
            padding: 0.5rem 1.5rem;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            clip-path: polygon(0% 0%, 100% 0%, 90% 100%, 10% 100%);
            border-bottom: 2px solid var(--neon-cyan);
            border-top: 2px solid var(--neon-cyan);
            min-width: 150px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .info-box span {
            display: inline-block;
            transition: transform 0.3s ease, color 0.3s ease;
        }
        
        .info-box span.pop {
             transform: scale(1.3);
             color: var(--success);
        }

        /* --- Main Layout --- */
        #main-content {
            display: flex;
            gap: 1.5rem;
            flex-grow: 1;
            height: 1px; /* Flexbox grow fix */
        }

        #game-container {
            flex-grow: 1;
            position: relative;
        }

        #game-board {
            width: 100%;
            height: 100%;
        }

        /* --- Sidebar --- */
        #sidebar {
            width: 320px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            z-index: 10;
        }

        .sidebar-section {
            padding: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        #comparison-section { flex-basis: 35%; }
        #progress-section { flex-grow: 1; }
        #controls-section { flex-basis: 25%; }

        .sidebar-title {
            font-family: 'Audiowide', sans-serif;
            font-size: 1.2rem;
            color: var(--neon-cyan);
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 0 0 5px var(--neon-cyan);
        }

        #comparison-slots {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 1rem;
            flex-grow: 1;
        }

        .comparison-slot {
            width: 120px;
            height: 120px;
            border: 2px dashed var(--glass-border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .comparison-slot.filled {
            border-style: solid;
            border-color: var(--neon-cyan);
            background: rgba(0, 229, 255, 0.1);
        }
        
        .comparison-slot.glow-success {
             animation: glow-success 0.8s ease-in-out;
        }
        
        @keyframes glow-success {
            0% { box-shadow: 0 0 0px rgba(0, 255, 136, 0); }
            50% { box-shadow: 0 0 20px 5px rgba(0, 255, 136, 0.7); }
            100% { box-shadow: 0 0 0px rgba(0, 255, 136, 0); }
        }

        #picture-reveal {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100%;
            height: 100%;
            aspect-ratio: 1;
            margin: auto;
            border-radius: 8px;
            overflow: hidden;
            background-image: url('https://placehold.co/400x400/0f0c29/e0e0ff?text=Quest+Complete');
            background-size: cover;
            position: relative;
        }

        .picture-tile {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, var(--bg-mid), var(--bg-end));
            transition: opacity 0.5s ease-in-out;
            border: 1px solid var(--glass-border);
        }

        .picture-tile.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #hq-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-top: auto;
        }

        .control-button {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            padding: 0.75rem 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .control-button:hover {
            background: var(--neon-cyan);
            color: var(--text-dark);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        #change-level-btn {
            grid-column: 1 / -1;
            background-image: linear-gradient(90deg, var(--neon-pink), var(--neon-cyan));
            color: var(--text-dark);
            border: none;
        }
         #change-level-btn:hover {
            box-shadow: 0 0 15px var(--neon-pink);
        }
        
        /* --- Triangles --- */
        .triangle-wrapper {
            position: absolute;
            cursor: grab;
            transition: box-shadow 0.3s ease;
            animation: float 4s infinite ease-in-out;
        }
        .triangle-wrapper.dragging {
            cursor: grabbing;
            z-index: 1000;
            animation: none;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.7);
        }

        .triangle-svg {
            display: block;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
        }

        .triangle-path {
            stroke: var(--neon-cyan);
            stroke-width: 3;
            fill: rgba(48, 43, 99, 0.8);
            transition: fill 0.3s ease;
        }

        .triangle-wrapper.dragging .triangle-path {
            fill: rgba(0, 229, 255, 0.3);
        }

        .triangle-text {
            font-family: 'Inter', sans-serif;
            fill: var(--text-light);
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        
        .triangle-highlight {
            transition: opacity 0.5s;
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            animation: pop-in 0.4s ease-out forwards;
            max-width: 500px;
            width: 90%;
            padding: 2.5rem;
            text-align: center;
        }
        
        .modal-content h2 {
            font-family: 'Audiowide', sans-serif;
            font-size: 2.5rem;
            color: var(--neon-cyan);
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .modal-content p {
            margin-bottom: 2rem;
            line-height: 1.6;
            color: var(--text-light);
        }
        
        #level-select-cards {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 1rem;
        }

        .level-card {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid var(--glass-border);
            padding: 1.5rem 1rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .level-card:hover {
            transform: translateY(-5px);
            background-color: var(--glass-bg);
            border-color: var(--neon-cyan);
        }

        .level-card-icon { margin-bottom: 0.75rem; font-size: 2rem; }
        .level-card-title { font-weight: bold; font-size: 1.1rem; }
        .level-card-desc { font-size: 0.8rem; opacity: 0.7; }

        #level0-triangles {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 2rem;
            min-height: 150px;
        }
        
        #level0-choices { display: flex; justify-content: center; gap: 1rem; }

        @keyframes pop-in {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .shake { animation: shake 0.5s ease-in-out; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-8px); }
            40%, 80% { transform: translateX(8px); }
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            body { padding: 1rem; }
            #main-content { flex-direction: column; }
            #sidebar { width: 100%; height: 300px; flex-direction: row; }
            #comparison-section, #progress-section, #controls-section { height: 100%; }
        }
        @media (max-width: 768px) {
            body { padding: 0.5rem; }
            #header { flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
            .info-hud { gap: 1rem; }
            .info-box { padding: 0.4rem 1rem; min-width: 120px; }
            #sidebar { height: auto; flex-direction: column; }
            #level-select-cards { grid-template-columns: 1fr; }
        }

    </style>
</head>
<body>

    <div id="stars-container"></div>

    <header id="header">
        <h1 class="game-title">AVENGERS TRIANGLE QUEST</h1>
        <div class="info-hud">
            <div id="level-display" class="info-box">LEVEL: -</div>
            <div id="score-display" class="info-box">SCORE: 0</div>
        </div>
    </header>

    <main id="main-content">
        <section id="game-container" class="glass-panel">
            <div id="game-board"></div>
        </section>

        <aside id="sidebar">
            <div id="comparison-section" class="sidebar-section glass-panel">
                 <h3 class="sidebar-title">COMPARISON ZONE</h3>
                 <div id="comparison-slots">
                     <div class="comparison-slot" data-slot="0"></div>
                     <div class="comparison-slot" data-slot="1"></div>
                 </div>
            </div>
            <div id="progress-section" class="sidebar-section glass-panel">
                 <h3 class="sidebar-title">MISSION PROGRESS</h3>
                 <div id="picture-reveal"></div>
            </div>
            <div id="controls-section" class="sidebar-section glass-panel">
                 <h3 class="sidebar-title">HQ CONTROLS</h3>
                 <div id="hq-controls">
                     <button id="hint-btn" class="control-button">Get Hint (-2)</button>
                     <button id="reveal-btn" class="control-button">Reveal Answers</button>
                     <button id="change-level-btn" class="control-button">Change Level</button>
                 </div>
            </div>
        </aside>
    </main>
    
    <div id="level-select-modal" class="modal-overlay">
        <div class="modal-content glass-panel">
            <h2>MISSION BRIEFING</h2>
            <p>Select your training level, Agent. Each level will test a different aspect of geometric similarity. Good luck.</p>
            <div id="level-select-cards">
                <div class="level-card" data-level="0">
                    <div class="level-card-icon">💡</div>
                    <div class="level-card-title">Level 0: The Basics</div>
                    <div class="level-card-desc">Identify similarity with simple choices.</div>
                </div>
                <div class="level-card" data-level="1">
                    <div class="level-card-icon">📐</div>
                    <div class="level-card-title">Level 1: Angle & Side Power</div>
                    <div class="level-card-desc">Master AAA and SSS criteria.</div>
                </div>
                <div class="level-card" data-level="2">
                    <div class="level-card-icon">📏</div>
                    <div class="level-card-title">Level 2: The SAS Challenge</div>
                    <div class="level-card-desc">Focus on the Side-Angle-Side rule.</div>
                </div>
                 <div class="level-card" data-level="3">
                    <div class="level-card-icon">💎</div>
                    <div class="level-card-title">Level 3: Infinity Gauntlet</div>
                    <div class="level-card-desc">A mix of all similarity criteria.</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="level0-modal" class="modal-overlay">
         <div class="modal-content glass-panel">
            <h2>Identify Similarity</h2>
            <p>Are the two triangles below similar? Choose the correct option.</p>
            <div id="level0-triangles"></div>
            <div id="level0-choices"></div>
            <button id="level0-next" class="control-button" style="margin-top: 1.5rem; display: none;">Next Pair</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const starsContainer = document.getElementById('stars-container');
            const gameBoard = document.getElementById('game-board');
            const levelDisplay = document.getElementById('level-display');
            const scoreDisplay = document.getElementById('score-display');
            const comparisonSlots = document.querySelectorAll('.comparison-slot');
            const pictureReveal = document.getElementById('picture-reveal');
            const hintBtn = document.getElementById('hint-btn');
            const revealBtn = document.getElementById('reveal-btn');
            const changeLevelBtn = document.getElementById('change-level-btn');
            const levelSelectModal = document.getElementById('level-select-modal');
            const level0Modal = document.getElementById('level0-modal');

            let gameState = {
                currentLevel: -1,
                score: 0,
                triangles: [],
                comparison: [null, null],
                draggingElement: null,
                offsetX: 0,
                offsetY: 0,
                placedTriangles: [],
                correctPairs: 0,
                totalPairs: 0,
                level0CurrentPair: null,
            };

            const LEVEL_CONFIG = {
                0: { name: "The Basics", types: ['AAA', 'SSS', 'SAS', 'Not Similar', 'Not Enough Data'] },
                1: { name: "Angle & Side Power", types: ['AAA', 'SSS'], distractors: 2, pairs: 5 },
                2: { name: "The SAS Challenge", types: ['SAS'], distractors: 2, pairs: 6 },
                3: { name: "Infinity Gauntlet", types: ['AAA', 'SSS', 'SAS'], distractors: 4, pairs: 7 },
            };
            
            const NICE_SIDE_SETS = [ [3, 4, 5], [5, 12, 13], [8, 15, 17], [7, 24, 25], [2, 3, 4], [4, 5, 6], [6, 8, 10] ];
            const NICE_SCALES = [1.5, 2, 2.5, 0.5];

            // --- Initialization ---
            function init() {
                createStars();
                for (let i = 0; i < 16; i++) { const tile = document.createElement('div'); tile.classList.add('picture-tile'); pictureReveal.appendChild(tile); }
                levelSelectModal.addEventListener('click', (e) => { const card = e.target.closest('.level-card[data-level]'); if (card) { const level = parseInt(card.dataset.level); levelSelectModal.classList.remove('visible'); startLevel(level); } });
                hintBtn.addEventListener('click', useHint);
                revealBtn.addEventListener('click', revealAnswers);
                changeLevelBtn.addEventListener('click', () => levelSelectModal.classList.add('visible'));
                document.getElementById('level0-next').addEventListener('click', () => runLevel0());

                levelSelectModal.classList.add('visible');
            }
            
            function createStars() {
                for (let i = 0; i < 100; i++) {
                    const star = document.createElement('div');
                    star.classList.add('star');
                    const size = Math.random() * 3 + 1;
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    star.style.top = `${Math.random() * 100}vh`;
                    star.style.left = `${Math.random() * 100}vw`;
                    star.style.animationDuration = `${Math.random() * 3 + 2}s`;
                    star.style.animationDelay = `${Math.random() * 3}s`;
                    starsContainer.appendChild(star);
                }
            }
            
            function startLevel(level) {
                resetGameState();
                gameState.currentLevel = level;
                levelDisplay.textContent = `LEVEL: ${level}`;
                
                const config = LEVEL_CONFIG[level];
                if (level > 0) {
                    gameState.triangles = generateTrianglesForLevel(level);
                    gameState.totalPairs = config.pairs;
                    renderTriangles();
                } else {
                    runLevel0();
                }
            }
            
            function resetGameState() {
                gameState.score = 0;
                gameState.triangles = [];
                gameState.comparison = [null, null];
                gameState.placedTriangles = [];
                gameState.correctPairs = 0;
                gameBoard.innerHTML = '';
                updateScore(0);
                comparisonSlots.forEach(s => { s.innerHTML = ''; s.classList.remove('filled'); });
                document.querySelectorAll('.picture-tile').forEach(t => t.classList.remove('hidden'));
            }

            // --- Level Generation ---
            function generateTrianglesForLevel(level) {
                const config = LEVEL_CONFIG[level];
                const triangles = [];
                let pairId = 0;
                for (let i = 0; i < config.pairs; i++) {
                    const type = config.types[Math.floor(Math.random() * config.types.length)];
                    triangles.push(...createSimilarPair(type, pairId));
                    pairId++;
                }
                for (let i = 0; i < config.distractors; i++) { triangles.push(createDistractor(config.types, pairId)); pairId++; }
                return shuffleArray(triangles);
            }
            
            function createSimilarPair(type, pairId) {
                const scale = NICE_SCALES[Math.floor(Math.random() * NICE_SCALES.length)];
                const t1 = { id: pairId * 2, pairId: pairId, type: type, isDistractor: false };
                const t2 = { id: pairId * 2 + 1, pairId: pairId, type: type, isDistractor: false };
                switch (type) {
                    case 'SSS':
                        const baseSides = NICE_SIDE_SETS[Math.floor(Math.random() * NICE_SIDE_SETS.length)];
                        const multiplier = rand(5, 10);
                        const sides1 = baseSides.map(s => s * multiplier);
                        t1.sides = sides1;
                        t2.sides = sides1.map(s => Math.round(s * scale));
                        break;
                    case 'SAS':
                        t1.sides = [rand(5, 10) * 5, rand(6, 12) * 5];
                        t1.angles = [null, rand(30, 120), null];
                        t2.sides = t1.sides.map(s => Math.round(s * scale));
                        t2.angles = [null, t1.angles[1], null];
                        break;
                    case 'AAA': const a1 = rand(30, 80), a2 = rand(30, 180 - a1 - 10), a3 = 180 - a1 - a2; t1.angles = [a1, a2, a3].map(a => Math.round(a)); t2.angles = t1.angles; break;
                } return [t1, t2];
            }

            function createDistractor(types, id) {
                const distractor = { id: id * 2, pairId: -1, isDistractor: true }; const type = types[Math.floor(Math.random() * types.length)]; distractor.type = type;
                switch (type) {
                    case 'SSS': distractor.sides = [rand(5, 10) * 5, rand(6, 12) * 5, rand(7, 14) * 5]; break;
                    case 'SAS': distractor.sides = [rand(5, 10) * 5, rand(6, 12) * 5]; distractor.angles = [null, rand(30, 120), null]; break;
                    case 'AAA': const a1 = rand(35, 85), a2 = rand(35, 180 - a1 - 10); distractor.angles = [a1, a2, 180 - a1 - a2].map(a => Math.round(a)); break;
                } return distractor;
            }
            
            // --- Rendering ---
            function renderTriangles() {
                gameBoard.innerHTML = '';
                gameState.placedTriangles = [];
                const boardRect = gameBoard.getBoundingClientRect();

                gameState.triangles.forEach((tri, index) => {
                    const { element, ...geo } = drawTriangle(tri);
                    tri.width = geo.width;
                    tri.height = geo.height;
                    element.style.animationDelay = `${index * 0.1}s`;
                    placeWithoutOverlap(element, tri, boardRect);
                    gameBoard.appendChild(element);
                    addDragListeners(element);
                });
            }
            
            function drawTriangle(tri, size = 120) {
                let a = size, b = size * 0.8, angleC = 60;
                if (tri.type === 'SSS' || tri.type === 'SAS') {
                    const maxSide = Math.max(...(tri.sides || [150, 150]));
                    const scale = size / maxSide;
                    a = tri.sides[0] * scale;
                    b = tri.sides[1] * scale;
                    if (tri.type === 'SSS') {
                        const c = tri.sides[2] * scale;
                        angleC = Math.acos((a*a + b*b - c*c) / (2*a*b)) * (180 / Math.PI);
                    } else { // SAS
                        angleC = tri.angles[1];
                    }
                } else if (tri.type === 'AAA') {
                    angleC = tri.angles[1];
                }

                const p1 = { x: 0, y: b * Math.sin(angleC * Math.PI / 180) };
                const p2 = { x: a, y: p1.y };
                const p3 = { x: b * Math.cos(angleC * Math.PI / 180), y: 0 };
                const points = [p1, p2, p3];
                const minX = Math.min(...points.map(p=>p.x)), maxX = Math.max(...points.map(p=>p.x));
                const minY = Math.min(...points.map(p=>p.y)), maxY = Math.max(...points.map(p=>p.y));
                const width = maxX - minX, height = maxY - minY;

                const wrapper = document.createElement('div');
                wrapper.className = 'triangle-wrapper';
                wrapper.dataset.id = tri.id;
                
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute('class', 'triangle-svg');
                svg.setAttribute('viewBox', `${minX-5} ${minY-5} ${width+10} ${height+10}`);
                svg.setAttribute('width', width+10);
                svg.setAttribute('height', height+10);
                
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('d', `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y} Z`);
                path.setAttribute('class', 'triangle-path');
                svg.appendChild(path);
                
                const textGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");

                const centroid = { x: (p1.x + p2.x + p3.x) / 3, y: (p1.y + p2.y + p3.y) / 3 };
                
                if (tri.sides) {
                    textGroup.appendChild(createText(tri.sides[0], (p1.x + p2.x)/2 + 5, (p1.y + p2.y)/2));
                    textGroup.appendChild(createText(tri.sides[1], (p2.x + p3.x)/2, (p2.y + p3.y)/2 - 5));
                    if (tri.sides[2]) textGroup.appendChild(createText(tri.sides[2], (p3.x + p1.x)/2 - 5, (p3.y + p1.y)/2));
                }
                if (tri.angles) {
                    if (tri.angles[0]) textGroup.appendChild(createText(`${tri.angles[0]}°`, p1.x, p1.y-10));
                    if (tri.angles[1]) textGroup.appendChild(createText(`${tri.angles[1]}°`, p2.x, p2.y-10));
                    if (tri.angles[2]) textGroup.appendChild(createText(`${tri.angles[2]}°`, p3.x, p3.y+10));
                }
                svg.appendChild(textGroup);
                wrapper.appendChild(svg);
                
                return { element: wrapper, width: width+10, height: height+10, path: path };
            }
            
            function createText(content, x, y) { const text = document.createElementNS("http://www.w3.org/2000/svg", "text"); text.setAttribute('class', 'triangle-text'); text.setAttribute('x', x); text.setAttribute('y', y); text.textContent = content; return text; }

            function placeWithoutOverlap(element, tri, boardRect) {
                let placed = false, attempts = 0, x, y;
                while (!placed && attempts < 200) {
                    x = Math.random() * (boardRect.width - tri.width - 20) + 10;
                    y = Math.random() * (boardRect.height - tri.height - 20) + 10;
                    const newRect = { x, y, width: tri.width, height: tri.height };
                    let collision = gameState.placedTriangles.some(p => rectsOverlap(newRect, p.rect));
                    if (!collision) placed = true;
                    attempts++;
                }
                element.style.left = `${x}px`;
                element.style.top = `${y}px`;
                const finalRect = { x, y, width: tri.width, height: tri.height };
                tri.x = x; tri.y = y;
                gameState.placedTriangles.push({ element, rect: finalRect, tri });
            }
            
            // --- Drag and Drop ---
            function addDragListeners(element) { element.addEventListener('mousedown', dragStart); element.addEventListener('touchstart', dragStart, { passive: false }); }
            function dragStart(e) { e.preventDefault(); if (e.target.closest('.triangle-wrapper')) { gameState.draggingElement = e.target.closest('.triangle-wrapper'); gameState.draggingElement.classList.add('dragging'); const rect = gameState.draggingElement.getBoundingClientRect(); const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX; const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY; gameState.offsetX = clientX - rect.left; gameState.offsetY = clientY - rect.top; document.addEventListener('mousemove', dragMove); document.addEventListener('mouseup', dragEnd); document.addEventListener('touchmove', dragMove, { passive: false }); document.addEventListener('touchend', dragEnd); } }
            function dragMove(e) { if (!gameState.draggingElement) return; e.preventDefault(); const boardRect = gameBoard.getBoundingClientRect(); const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX; const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY; let x = clientX - boardRect.left - gameState.offsetX; let y = clientY - boardRect.top - gameState.offsetY; gameState.draggingElement.style.left = `${x}px`; gameState.draggingElement.style.top = `${y}px`; }
            function dragEnd(e) {
                if (!gameState.draggingElement) return;
                const element = gameState.draggingElement;
                element.classList.remove('dragging');
                document.removeEventListener('mousemove', dragMove); document.removeEventListener('mouseup', dragEnd); document.removeEventListener('touchmove', dragMove); document.removeEventListener('touchend', dragEnd);
                
                const elementRect = element.getBoundingClientRect();
                let droppedInSlot = false;
                for (const [i, slot] of comparisonSlots.entries()) {
                    if (rectsOverlap(elementRect, slot.getBoundingClientRect()) && gameState.comparison[i] === null) {
                        handleDropInSlot(element, i);
                        droppedInSlot = true;
                        break;
                    }
                }
                
                if (!droppedInSlot) {
                    const triId = parseInt(element.dataset.id);
                    const placedTri = gameState.placedTriangles.find(p => p.tri.id === triId);
                    if (placedTri) {
                        const boardRect = gameBoard.getBoundingClientRect();
                        const newX = elementRect.left - boardRect.left;
                        const newY = elementRect.top - boardRect.top;
                        placedTri.rect.x = newX;
                        placedTri.rect.y = newY;
                        placedTri.tri.x = newX;
                        placedTri.tri.y = newY;
                    }
                }
                
                gameState.draggingElement = null;
            }
            
            function handleDropInSlot(element, slotIndex) {
                const id = parseInt(element.dataset.id);
                const tri = gameState.triangles.find(t => t.id === id);
                gameState.comparison[slotIndex] = tri;
                const slot = comparisonSlots[slotIndex];
                slot.innerHTML = '';
                const { element: newElement } = drawTriangle(tri, 80);
                newElement.style.position = 'static';
                newElement.classList.remove('dragging');
                slot.appendChild(newElement);
                slot.classList.add('filled');
                element.style.display = 'none';
                
                if (gameState.comparison[0] && gameState.comparison[1]) {
                    setTimeout(checkPair, 200);
                }
            }

            // --- Game Logic ---
            function checkPair() {
                const [t1, t2] = gameState.comparison;
                if (t1.isDistractor || t2.isDistractor || t1.pairId !== t2.pairId) {
                    handleIncorrectMatch();
                } else {
                    handleCorrectMatch();
                }
            }
            
            function handleCorrectMatch() {
                updateScore(10);
                gameState.correctPairs++;
                revealPictureTile();
                const [t1, t2] = gameState.comparison;
                
                comparisonSlots.forEach(slot => {
                    slot.classList.add('glow-success');
                    setTimeout(() => slot.classList.remove('glow-success'), 800);
                });
                
                setTimeout(() => {
                    gameState.triangles = gameState.triangles.filter(t => t.id !== t1.id && t.id !== t2.id);
                    gameState.placedTriangles = gameState.placedTriangles.filter(p => p.tri.id !== t1.id && p.tri.id !== t2.id);
                    
                    const el1 = gameBoard.querySelector(`.triangle-wrapper[data-id="${t1.id}"]`);
                    const el2 = gameBoard.querySelector(`.triangle-wrapper[data-id="${t2.id}"]`);
                    if(el1) el1.remove();
                    if(el2) el2.remove();
                    
                    resetComparisonSlots();
                    
                    if (gameState.correctPairs === gameState.totalPairs) {
                        alert("Level Complete!");
                        levelSelectModal.classList.add('visible');
                    }
                }, 1000);
            }
            
            function handleIncorrectMatch() {
                updateScore(-5);
                const [t1, t2] = gameState.comparison;
                
                comparisonSlots.forEach(slot => slot.classList.add('shake'));
                setTimeout(() => comparisonSlots.forEach(slot => slot.classList.remove('shake')), 500);
                
                setTimeout(() => {
                    if (t1) gameBoard.querySelector(`.triangle-wrapper[data-id="${t1.id}"]`).style.display = 'block';
                    if (t2) gameBoard.querySelector(`.triangle-wrapper[data-id="${t2.id}"]`).style.display = 'block';
                    resetComparisonSlots();
                }, 1000);
            }
            
            function resetComparisonSlots() {
                gameState.comparison = [null, null];
                comparisonSlots.forEach(s => {
                    s.innerHTML = '';
                    s.classList.remove('filled');
                });
            }
            
            function updateScore(change) {
                gameState.score += change;
                scoreDisplay.textContent = `SCORE: ${gameState.score}`;
                const span = document.createElement('span');
                span.textContent = change > 0 ? `+${change}` : `${change}`;
                span.className = 'pop';
                scoreDisplay.appendChild(span);
                setTimeout(() => span.remove(), 500);
            }
            
            function revealPictureTile() {
                const hiddenTiles = document.querySelectorAll('.picture-tile:not(.hidden)');
                if (hiddenTiles.length > 0) {
                    hiddenTiles[Math.floor(Math.random() * hiddenTiles.length)].classList.add('hidden');
                }
            }

            // --- Controls ---
            function useHint() {
                if (gameState.score < 2) return;
                updateScore(-2);
                const remainingPairs = {};
                gameState.triangles.forEach(t => {
                    if (!t.isDistractor) {
                        if (!remainingPairs[t.pairId]) remainingPairs[t.pairId] = [];
                        remainingPairs[t.pairId].push(t);
                    }
                });
                
                for (const pairId in remainingPairs) {
                    if (remainingPairs[pairId].length === 2) {
                        const [t1, t2] = remainingPairs[pairId];
                        const el1 = gameBoard.querySelector(`.triangle-wrapper[data-id="${t1.id}"]`);
                        const el2 = gameBoard.querySelector(`.triangle-wrapper[data-id="${t2.id}"]`);
                        handleDropInSlot(el1, 0);
                        handleDropInSlot(el2, 1);
                        return;
                    }
                }
            }

            function revealAnswers() {
                const colors = ['#ff6347', '#ffd700', '#adff2f', '#00ced1', '#9932cc', '#ff1493', '#1e90ff'];
                const pairs = {};
                gameState.triangles.forEach(t => {
                    if (!t.isDistractor) {
                        if (!pairs[t.pairId]) pairs[t.pairId] = [];
                        pairs[t.pairId].push(t);
                    } else {
                        const el = gameBoard.querySelector(`.triangle-wrapper[data-id="${t.id}"]`);
                        if (el) el.style.opacity = '0.3';
                    }
                });

                let colorIndex = 0;
                for (const pairId in pairs) {
                    if (pairs[pairId].length === 2) {
                        const color = colors[colorIndex % colors.length];
                        pairs[pairId].forEach(t => {
                            const el = gameBoard.querySelector(`.triangle-wrapper[data-id="${t.id}"]`);
                            if (el) {
                                el.querySelector('.triangle-path').style.stroke = color;
                                el.style.animation = 'none';
                            }
                        });
                        colorIndex++;
                    }
                }
                hintBtn.disabled = true;
                revealBtn.disabled = true;
            }
            
            // --- Level 0 Logic ---
            function runLevel0() {
                level0Modal.classList.add('visible');
                const nextBtn = document.getElementById('level0-next');
                nextBtn.style.display = 'none';
                
                const type = LEVEL_CONFIG[0].types[Math.floor(Math.random() * LEVEL_CONFIG[0].types.length)];
                let t1, t2;
                let answer;

                if (type === 'Not Similar' || type === 'Not Enough Data') {
                     t1 = createDistractor(['SSS','SAS','AAA'], 1);
                     t2 = createDistractor(['SSS','SAS','AAA'], 2);
                     answer = type;
                     if(type === 'Not Enough Data') {
                        t1.sides = [t1.sides[0]]; // Show only one side
                        t2.sides = [t2.sides[0]];
                     }
                } else {
                    [t1, t2] = createSimilarPair(type, 1);
                    answer = "Similar";
                }
                gameState.level0CurrentPair = {t1, t2, answer};
                
                const container = document.getElementById('level0-triangles');
                container.innerHTML = '';
                container.appendChild(drawTriangle(t1, 120).element);
                container.appendChild(drawTriangle(t2, 120).element);
                
                const choicesContainer = document.getElementById('level0-choices');
                choicesContainer.innerHTML = '';
                ['Similar', 'Not Similar', 'Not Enough Data'].forEach(choice => {
                    const btn = document.createElement('button');
                    btn.textContent = choice;
                    btn.className = 'control-button';
                    btn.onclick = () => handleLevel0Choice(choice);
                    choicesContainer.appendChild(btn);
                });
            }
            
            function handleLevel0Choice(choice) {
                const { answer } = gameState.level0CurrentPair;
                const choicesContainer = document.getElementById('level0-choices');
                const nextBtn = document.getElementById('level0-next');

                if (choice === answer) {
                    updateScore(10);
                    choicesContainer.innerHTML = `<p style="color: var(--success);">Correct!</p>`;
                } else {
                    updateScore(-5);
                    choicesContainer.innerHTML = `<p style="color: var(--danger);">Incorrect. The correct answer was ${answer}.</p>`;
                }
                nextBtn.style.display = 'inline-block';
            }


            // --- Helpers ---
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            function rectsOverlap(rect1, rect2) { return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom); }

            // Start the game
            init();
        });
    </script>
</body>
</html>

